
import glob
import os
import sys


# Setup logging for the cross3d library.
# To access the logger object call cross3d.logger. If the environment variable 
# "CROSS3D_LOGGING_LEVEL" is set a StreamHandler will be created that prints all 
# output to sys.stdout. Otherwise it will create a NullHandler.
#--------------------------------------------------------------------------------
import logging as _logging
logger = _logging.getLogger(__name__)
if not logger.handlers:
	_logLevel = int(os.getenv('CROSS3D_LOGGING_LEVEL', _logging.NOTSET))
	if _logLevel:
		ch = _logging.StreamHandler(sys.stdout)
		ch.setLevel(_logLevel)
		formatter = _logging.Formatter('%(levelname)s:%(name)s [%(filename)s:%(lineno)d]# %(message)s')
		ch.setFormatter(formatter)
		logger.addHandler(ch)
		logger.setLevel(_logLevel)
	else:
		logger.addHandler(_logging.NullHandler())
#--------------------------------------------------------------------------------

# Create a cross3d library debug level
# This allows developers to create additional workflows inside the code that helps
# with debugging and development. By default it defaults to DebugLevels.Disabled,
# but you can control the default with the "CROSS3D_DEBUG_LEVEL" environment variable.
# To change the current debug level:
# 		cross3d.debugLevel = cross3d.constants.DebugLevels.Mid
# To check if the current debug level is Mid or higher:
#		cross3d.debugLevel >= cross3d.constants.DebugLevels.Mid
from constants import DebugLevels as _DebugLevels
debugLevel = _DebugLevels[os.getenv('CROSS3D_DEBUG_LEVEL', 'Disabled')]

#--------------------------------------------------------------------------------
# Decorators and functions used for maintaining cross3d
#--------------------------------------------------------------------------------

def abstractmethod(function):
	""" The decorated function should be overridden by a software specific module.
	
	Depending on the state of the environment variable "CROSS3D_ABSTRACT_MODE" is set to 
	"""
	def newFunction(*args, **kwargs):
		# when debugging, raise an error
		msg = 'Abstract implementation has not been overridden.'
		mode = os.getenv('CROSS3D_ABSTRACTMETHOD_MODE')
		if mode == 'raise':
			raise NotImplementedError(debugObjectString(function, msg))
		elif mode == 'warn':
			logger.debug(debugObjectString(function, msg))
		return function(*args, **kwargs)
	newFunction.__name__ = function.__name__
	newFunction.__doc__ = function.__doc__
	newFunction.__dict__ = function.__dict__
	return newFunction

def debugObjectString(object, msg):
	import inspect
	# debug a module
	if inspect.ismodule(object):
		return '[%s module] :: %s' % (object.__name__, msg)

	# debug a class
	elif inspect.isclass(object):
		return '[%s.%s class] :: %s' % (object.__module__, object.__name__, msg)

	# debug an instance method
	elif inspect.ismethod(object):
		return '[%s.%s.%s method] :: %s' % (object.im_class.__module__, object.im_class.__name__, object.__name__, msg)

	# debug a function
	elif inspect.isfunction(object):
		return '[%s.%s function] :: %s' % (object.__module__, object.__name__, msg)

#--------------------------------------------------------------------------------
# cross3d init
#--------------------------------------------------------------------------------

# By default cross3d suppresses exceptions when it imports the software specific module. It uses the
# first module that successfully imports. When programming a software specific module this makes it
# hard to debug. 
# If you set the environment variable CROSS3D_DEBUG_MODULE to the name of the module you are working 
# on it will only try to load that module(and abstract) and it will raise all exceptions.
_debugModule = os.getenv('CROSS3D_DEBUG_MODULE')
logger.debug('DebugModule: {}'.format(_debugModule))

import constants

from classes import FCurve
from classes import Exceptions
from classes import ValueRange
from classes import FrameRange
from classes import FileSequence
from classes import Timecode
from classes import Clipboard
from classes import FlipBook
from classes import Dispatch as _Dispatch

# Global Dispatch object.  This is the main entry point for connecting to events and signals generated by the 3D environment.
dispatch = _Dispatch()

def _methodNames():
	filenames = glob.glob(os.path.split(__file__)[0] + '/*/__init__.py')
	ret = []
	for filename in filenames:
		modname = os.path.normpath(filename).split(os.path.sep)[-2]
		if (modname != 'abstract'):
			ret.append(os.path.normpath(filename).split(os.path.sep)[-2])
	return ret

def packageName(modname):
	return 'cross3d.%s' % modname

def init():
	if _debugModule != None:
		logger.debug('Forced import of Software Specific module: {}'.format(_debugModule))
		# TODO: Research a better way to handle importing the software specific modules
		pckg = packageName(_debugModule)
		__import__(pckg)
		mod = sys.modules[pckg]
		logger.debug('pckg: {}'.format([pckg, mod]))
		mod.init()
	else:
		# import any overrides to the abstract symbols
		for modname in _methodNames():
			pckg = packageName(modname)

			# Attempt to import and init this modname.
			try:
				__import__(pckg)
			except ImportError:
				continue

			mod = sys.modules[pckg]
			try:
				mod.init()
				logger.debug('The module "{}" initialized successfully.'.format(modname))
				# The module successfully initalized no need to try any other modules.
				break
			except:
				continue

	# import the abstract api for default implementations of api
	import abstract
	abstract.init()

def external(appName):
	appName = appName.lower()
	# classes should not have a external implementation
	if appName == 'classes':
		raise KeyError('classes does not have a external implementation.')
	import cross3d
	try:
		__import__(packageName(appName))
		return getattr(getattr(getattr(cross3d, appName), 'external'), 'External')
	except AttributeError:
		return cross3d.abstract.external.External

def registerSymbol(name, value, ifNotFound=False):
	"""
		Used by the *adaptors* to register their own classes and functions as
		part of the cross3d.  
	"""
	# initialize a value in the dictionary
	import cross3d
	if ifNotFound and name in cross3d.__dict__:
		return

	cross3d.__dict__[name] = value

init()
